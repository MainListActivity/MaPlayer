// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../config.dart';
import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `compute_session_id`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `Engine`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`, `from`

/// Initialize the proxy engine with the given configuration.
///
/// Idempotent â€” if already initialized, returns `Ok(())`.
void initEngine({required EngineConfig config}) =>
    RustLib.instance.api.crateApiProxyApiInitEngine(config: config);

/// Create a new proxy session for the given source URL.
///
/// Returns an existing session if one already exists with the same session ID.
/// Otherwise clears previous sessions and creates a new one.
SessionInfo createSession({
  required String url,
  required Map<String, String> headers,
  required String fileKey,
}) => RustLib.instance.api.crateApiProxyApiCreateSession(
  url: url,
  headers: headers,
  fileKey: fileKey,
);

/// Close an existing proxy session and remove it from the map.
void closeSession({required String sessionId}) =>
    RustLib.instance.api.crateApiProxyApiCloseSession(sessionId: sessionId);

/// Return a snapshot of current session statistics.
///
/// If `session_id` is provided, returns stats for that session only.
/// If `None`, aggregates stats across all active sessions.
ProxyStats getStats({String? sessionId}) =>
    RustLib.instance.api.crateApiProxyApiGetStats(sessionId: sessionId);

/// Update authentication credentials for an active session.
void updateSessionAuth({
  required String sessionId,
  required String newUrl,
  required Map<String, String> newHeaders,
}) => RustLib.instance.api.crateApiProxyApiUpdateSessionAuth(
  sessionId: sessionId,
  newUrl: newUrl,
  newHeaders: newHeaders,
);

/// Shut down the proxy engine and release all resources.
void dispose() => RustLib.instance.api.crateApiProxyApiDispose();

/// Live statistics for a proxy session (or aggregated across all sessions).
class ProxyStats {
  final BigInt downloadBps;
  final BigInt serveBps;
  final BigInt bufferedBytesAhead;
  final int activeWorkers;
  final double cacheHitRate;

  const ProxyStats({
    required this.downloadBps,
    required this.serveBps,
    required this.bufferedBytesAhead,
    required this.activeWorkers,
    required this.cacheHitRate,
  });

  @override
  int get hashCode =>
      downloadBps.hashCode ^
      serveBps.hashCode ^
      bufferedBytesAhead.hashCode ^
      activeWorkers.hashCode ^
      cacheHitRate.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ProxyStats &&
          runtimeType == other.runtimeType &&
          downloadBps == other.downloadBps &&
          serveBps == other.serveBps &&
          bufferedBytesAhead == other.bufferedBytesAhead &&
          activeWorkers == other.activeWorkers &&
          cacheHitRate == other.cacheHitRate;
}

/// Information about an active proxy session.
class SessionInfo {
  final String sessionId;
  final String playbackUrl;
  final BigInt contentLength;
  final String contentType;

  const SessionInfo({
    required this.sessionId,
    required this.playbackUrl,
    required this.contentLength,
    required this.contentType,
  });

  @override
  int get hashCode =>
      sessionId.hashCode ^
      playbackUrl.hashCode ^
      contentLength.hashCode ^
      contentType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SessionInfo &&
          runtimeType == other.runtimeType &&
          sessionId == other.sessionId &&
          playbackUrl == other.playbackUrl &&
          contentLength == other.contentLength &&
          contentType == other.contentType;
}
